1.Create a new process by invoking the appropriate system call.
 Get the process identifier of the currently running process and 
its respective parent using system calls and display the same using 
a C program.

#include<stdio.h> 
#include<sys/types.h> 
#include<sys/types.h> 
#include<sys/wait.h> 
#include<unistd.h> 
#include<unistd.h> 
#include<stdlib.h> 
int main(void) 
{ 
 pid_t pid=fork(); 
 if(pid==0){ 
 printf("Child=>PPID:%d\n PID:%d\n",getpid(),getpid()); 
 exit(EXIT_SUCCESS); 
 } 
 else if(pid>0){ 
 printf("Parent=>PID:%d\n",getpid()); 
 printf("Waiting for child process to finish\n"); 
 wait(NULL); 
 printf("Child process finished\n"); 
 } 
 else{ 
 printf("Unable to create child process\n"); 
 } 
 return EXIT_SUCCESS; 
}


o/p:

2. Identify the system calls to copy the content of one file to
 another and illustrate the same using a C program.

#include <stdio.h> 
#include <stdlib.h> 
int main(){ 
 FILE *f1,*f2; 
 char filename[100],c; 
 f1=fopen("D:\kiran\a.txt","r"); 
 f2=fopen("D:\kiran\b.txt","w"); 
 c=fgetc(f1); 
 while(c!=EOF){ 
 fputc(c,f2); 
 c=fgetc(f1); 
 } 
 printf("THE CONTENT HAS BEEN COPIED SUCCESFULLY"); 
 fclose(f1); 
 fclose(f2); 
return 0; 
}

3. Design a CPU scheduling program with C using First Come First
 Served technique with the following considerations. 
a. All processes are activated at time 0. 
b. Assume that no process waits on I/O devices.
#include<stdio.h> 
int main() 
{ 
int n,bt[20],wt[20],tat[20],avwt=0,avtat=0,i,j; 
printf("Enter total number of processes(maximum 20):"); 
scanf("%d",&n); 
printf("\nEnter Process Burst Time\n"); 
for(i=0;i<n;i++) 
{ 
printf("P[%d]:",i+1); 
scanf("%d",&bt[i]); 
} 
wt[0]=0;for(i=1;i<n;i++) 
{ 
wt[i]=0; 
for(j=0;j<i;j++) 
wt[i]+=bt[j]; 
} 
printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time"); 
for(i=0;i<n;i++) 
{ 
tat[i]=bt[i]+wt[i]; 
avwt+=wt[i]; 
avtat+=tat[i]; 
printf("\nP[%d]\t\t%d\t\t%d\t\t%d",i+1,bt[i],wt[i],tat[i]); 
} 
avwt/=i; 
avtat/=i; 
printf("\n\nAverage Waiting Time:%d",avwt); 
printf("\nAverage Turnaround Time:%d",avtat); 
return 0; 
}

4. Construct a scheduling program with C that selects the waiting 
process with the smallest execution time to execute next.
#include<stdio.h> 
int main() 
{ 
int A[100][4]; 
int i, j, n, total = 0, index, temp; float avg_wt, avg_tat; 
printf("Enter number of process: "); 
scanf("%d", &n); 
printf("Enter Burst Time:\n"); 
 for (i = 0; i < n; i++) { 
printf("P%d: ", i + 1); 
scanf("%d", &A[i][1]); 
A[i][0] = i + 1; 
} 
for (i = 0; i < n; i++) { 
index = i; 
for (j = i + 1; j < n; j++) 
if (A[j][1] < A[index][1]) index = j; 
temp = A[i][1]; A[i][1] = A[index][1]; A[index][1] = temp; 
temp = A[i][0]; 
A[i][0] = A[index][0]; A[index][0] = temp; 
} 
A[0][2] = 0; 
for (i = 1; i < n; i++) { 
A[i][2] = 0; 
for (j = 0; j < i; j++) 
A[i][2] += A[j][1]; 
total += A[i][2]; 
} 
avg_wt = (float)total / n; total = 0; 
printf("P BT WT TAT\n"); for (i = 0; i < n; i++) { 
A[i][3] = A[i][1] + A[i][2]; 
total += A[i][3]; 
printf("P%d %d %d %d\n", A[i][0], A[i][1], A[i][2], A[i][3]); 
} 
avg_tat = (float)total / n; 
printf("Average Waiting Time= %f", avg_wt); printf("\nAverage Turnaround Time= %f", avg_tat); 
}

5. Construct a scheduling program with C that selects the waiting 
process with the highest priority to execute next.

#include<stdio.h>
struct priority_scheduling {
  char process_name;
  int burst_time;
  int waiting_time;
  int turn_around_time;
  int priority;
};

int main() {
  int number_of_process;
  int total = 0,i,j;
  struct priority_scheduling temp_process;
  int ASCII_number = 65;
  int position;
  float average_waiting_time;
  float average_turnaround_time;
  printf("Enter the total number of Processes: ");
  scanf("%d", & number_of_process);
  struct priority_scheduling process[number_of_process];

  printf("\nPlease Enter the  Burst Time and Priority of each process:\n");
  for (i = 0; i < number_of_process; i++) {
    process[i].process_name = (char) ASCII_number;

    printf("\nEnter the details of the process %c \n", process[i].process_name);
    printf("Enter the burst time: ");
    scanf("%d", & process[i].burst_time);

    printf("Enter the priority: ");
    scanf("%d", & process[i].priority);


    ASCII_number++;

  }

  for (i = 0; i < number_of_process; i++) {

    position = i;

    for (j = i + 1; j < number_of_process; j++) {

      if (process[j].priority > process[position].priority)
        position = j;
    }
    temp_process = process[i];
    process[i] = process[position];
    process[position] = temp_process;
  }
  process[0].waiting_time = 0;

  for (i = 1; i < number_of_process; i++) {
    process[i].waiting_time = 0;
    for (j = 0; j < i; j++) {
      process[i].waiting_time += process[j].burst_time;
    }
          
    total += process[i].waiting_time;
  }

  average_waiting_time = (float) total / (float) number_of_process;

  total = 0;

  printf("\n\nProcess_name \t Burst Time \t Waiting Time \t  Turnaround Time\n");
  printf("------------------------------------------------------------\n");

  for (i = 0; i < number_of_process; i++) {
    process[i].turn_around_time = process[i].burst_time + process[i].waiting_time;
    total += process[i].turn_around_time;
    printf("\t  %c \t\t  %d \t\t %d \t\t %d", process[i].process_name, process[i].burst_time, process[i].waiting_time, process[i].turn_around_time);
    printf("\n-----------------------------------------------------------\n");
  }
  average_turnaround_time = (float) total / (float) number_of_process;
  printf("\n\n Average Waiting Time : %f", average_waiting_time);
  printf("\n Average Turnaround Time: %f\n", average_turnaround_time);

  return 0;
}


6. Construct a C program to simulate Round Robin scheduling algorithm with C.

#include<stdio.h>  
#include<conio.h>  
  
void main()  
{ 
    int i, NOP, sum=0,count=0, y, quant, wt=0, tat=0, at[10], bt[10], temp[10];  
    float avg_wt, avg_tat;  
    printf(" Total number of process in the system: ");  
    scanf("%d", &NOP);  
    y = NOP; 
for(i=0; i<NOP; i++)  
{  
printf("\n Enter the Arrival and Burst time of the Process[%d]\n", i+1);  
printf(" Arrival time is: \t");  
scanf("%d", &at[i]);  
printf(" \nBurst time is: \t");  
scanf("%d", &bt[i]);  
temp[i] = bt[i]; 
}  
printf("Enter the Time Quantum for the process: \t");  
scanf("%d", &quant);   
printf("\n Process No \t\t Burst Time \t\t TAT \t\t Waiting Time ");  
for(sum=0, i = 0; y!=0; )  
{  
if(temp[i] <= quant && temp[i] > 0)  
{  
    sum = sum + temp[i];  
    temp[i] = 0;  
    count=1;  
    }     
    else if(temp[i] > 0)  
    {  
        temp[i] = temp[i] - quant;  
        sum = sum + quant;    
    }  
    if(temp[i]==0 && count==1)  
    {  
        y--;  
        printf("\nProcess No[%d] \t\t %d\t\t\t\t %d\t\t\t %d", i+1, bt[i], sum-at[i], sum-at[i]-bt[i]);  
        wt = wt+sum-at[i]-bt[i];  
        tat = tat+sum-at[i];  
        count =0;     
    }  
    if(i==NOP-1)  
    {  
        i=0;  
    }  
    else if(at[i+1]<=sum)  
    {  
        i++;  
    }  
    else  
    {  
        i=0;  
    }  
}    
avg_wt = wt * 1.0/NOP;  
avg_tat = tat * 1.0/NOP;  
printf("\n Average Turn Around Time: \t%f", avg_wt);  
printf("\n Average Waiting Time: \t%f", avg_tat);  
getch();  
}

7. Illustrate the concept of inter-process communication using 
shared memory with a C program.

#include<stdio.h>  
#include<stdlib.h>  
#include<unistd.h>   
#include<string.h>  
int main()  
{  
int i,key_t,IPC_CREAT=0;  
void *shared_memory;  
char buff[100];  
int shmid;  
shmid=shmget(key_t=2345, 1024, 0666|IPC_CREAT);   
printf("Key of shared memory is %d\n",shmid);  
shared_memory=shmat(shmid,NULL,0);    
printf("Process attached at %p\n",shared_memory);     
printf("Enter some data to write to shared memory\n");  
read(0,buff,100);  
strcpy(shared_memory,buff);  
printf("You wrote : %s\n",(char *)shared_memory);  
} 
  
8. Illustrate the concept of multithreading using a C program.
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>  
#include <pthread.h>
void *myThreadFun(void *vargp)
{
    sleep(1);
    printf("Hello World!! \n");
    return NULL;
}
  
int main()
{
    pthread_t thread_id;
    printf("Before Thread\n");
    pthread_create(&thread_id, NULL, myThreadFun, NULL);
    pthread_join(thread_id, NULL);
    printf("After Thread\n");
    exit(0);
}

9. Design a C program to simulate the concept of Dining-Philosophers
 problem
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>

sem_t diningroom;
sem_t chopstick[5];

void * coustmer(void *);
void eat(int);
int main()
{
	int i,a[5];
	pthread_t tid[5];
	
	sem_init(&diningroom,0,4);
	
	for(i=0;i<5;i++)
		sem_init(&chopstick[i],0,1);
		
	for(i=0;i<5;i++){
		a[i]=i;
		pthread_create(&tid[i],NULL,coustmer,(void *)&a[i]);
	}
	for(i=0;i<5;i++)
		pthread_join(tid[i],NULL);
}

void * coustmer(void * num)
{
	int c=*(int *)num;

	sem_wait(&diningroom);
	printf("\ncoustmer %d has entered room",c);
	sem_wait(&chopstick[c]);
	sem_wait(&chopstick[(c+1)%5]);

	eat(c);
	sleep(2);
	printf("\ncoustmer %d has finished eating",c);

	sem_post(&chopstick[(c+1)%5]);
	sem_post(&chopstick[c]);
	sem_post(&diningroom);
}

void eat(int c)
{
	printf("\ncoustmer %d is eating",c);
}


10. Construct a C program for implementation of memory allocation 
using first fit strategy.

#include<stdio.h>
void main()
{
	int blocksize[10], processessize[10], b, p, f[10], allocation[10], i, j;
	for(i = 0; i < 10; i++)
	{
		f[i] = 0;
		allocation[i] = -1;
	}
	printf("Enter no. of blocks: ");
	scanf("%d", &b);
	printf("\nEnter size of each block: ");
	for(i = 0; i < b; i++)
		scanf("%d", &blocksize[i]);
	printf("\nEnter no. of processes: ");
	scanf("%d", &p);
	printf("\nEnter size of each process: ");
	for(i = 0; i < p; i++)
		scanf("%d", &processessize[i]);
	for(i = 0; i < p; i++)        
		for(j = 0; j < b; j++)
			if(f[j] == 0 && blocksize[j] >= processessize[i])
			{
				allocation[j] = i;
				f[j] = 1;
				break;
			}
	printf("\nBlock no.\tsize\t\tprocess no.\t\tsize");
	for(i = 0; i < b; i++)
	{
		printf("\n%d\t\t%d\t\t", i+1, blocksize[i]);
		if(f[i] == 1)
			printf("%d\t\t\t%d",allocation[i]+1,processessize[allocation[i]]);
		else
			printf("Not allocated");
	}
}


11. Construct a C program to organize the file using single level directory.
#include<stdio.h>
#include<conio.h>
#include<string.h>
void main()
{
int f=0,i=0,j=0,ch;
char d[10],fname[10][10],name[10];
 int clrscr();
printf("Enter the directory name:");
scanf("%s",d);
printf("Enter the number of files:");
scanf("%d",&f);
do
{
printf("Enter file name to be created:");
scanf("%s",name);
for(i=0;i<f;i++)
{
if(!strcmp(name,fname[i]))
break;
}
if(i==f)
{
strcpy(fname[j++],name);
f++;
}
else
printf("There is already %s\n",name);
printf("Do you want to enter another file(yes - 1 or no - 0):");
scanf("%d",&ch);
}
while(ch==1);
printf("Directory name is:%s\n",d);
printf("Files names are:");
for(i=0;i<j;i++)
{
printf("\n%s",fname[i]);
}
getch();
}

12. Design a C program to organize the file using two level directory 
structure.
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
struct
{
char dname[10],fname[10][10];
int fcnt;
}dir[10];
void main()
{
int i,ch,dcnt,k;
char f[30], d[30];
dcnt=0;
while(1)
{
printf("\n\n1. Create Directory\t2. Create File\t3. Delete File");
printf("\n4. Search File\t\t5. Display\t6. Exit\t\nEnter your choice -- ");
scanf("%d",&ch);
switch(ch)
{
case 1: printf("\nEnter name of directory -- ");
scanf("%s", dir[dcnt].dname);
dir[dcnt].fcnt=0;
dcnt++;
printf("Directory created");
break;
case 2: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
if(strcmp(d,dir[i].dname)==0)
{
printf("Enter name of the file -- ");
scanf("%s",dir[i].fname[dir[i].fcnt]);
printf("File created");
break;
}
if(i==dcnt)
printf("Directory %s not found",d);
break;
case 3: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
{
if(strcmp(d,dir[i].dname)==0)
{
printf("Enter name of the file -- ");
scanf("%s",f);
for(k=0;k<dir[i].fcnt;k++)
{
if(strcmp(f, dir[i].fname[k])==0)
{
printf("File %s is deleted ",f);
dir[i].fcnt--;
strcpy(dir[i].fname[k],dir[i].fname[dir[i].fcnt]);
goto jmp;
}
}
printf("File %s not found",f);
goto jmp;
}
}
printf("Directory %s not found",d);
jmp : break;
case 4: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
{
if(strcmp(d,dir[i].dname)==0)
{
printf("\nEnter the name of the file -- ");
scanf("%s",f);
for(k=0;k<dir[i].fcnt;k++)
{
if(strcmp(f, dir[i].fname[k])==0)
{
printf("File %s is found ",f);
goto jmp1;
}
}
printf("File %s not found",f);
goto jmp1;
}
}
printf("Directory %s not found",d);
jmp1: break;
case 5: if(dcnt==0)
printf("\nNo Directory's ");
else
{
printf("\nDirectory\tFiles");
for(i=0;i<dcnt;i++)
{
printf("\n%s\t\t",dir[i].dname);
for(k=0;k<dir[i].fcnt;k++)
printf("\t%s",dir[i].fname[k]);
}
}
break;
default:exit(0);
}
}
}


13. Develop a C program for implementing random access file for processing
 the employee details.
#include <stdio.h>
            
    struct employeeData {                              
    unsigned int idNum; 
    char lastName[ 15 ];    
    char firstName[ 10 ];   
    double balance;   
    };                  
 
    int main( void )  { 
    FILE *cfPtr; 

    struct employeeData employee = { 0, "", "", 0.0 };

    if ( ( cfPtr = fopen( "a.txt", "rb+" ) ) == NULL ) {
      puts( "File could not be opened." );
    }
    else { 

      printf( "%s", "Enter account number"
         " ( 1 to 100, 0 to end input )\n? " );
		 scanf( "%d", &employee.idNum );

    while ( employee.idNum != 0 ) { 
 
    printf( "%s", "Enter lastname, firstname, balance\n? " );

    fscanf( stdin, "%14s%9s%lf",employee.lastName, 
              employee.firstName, &employee.balance );
  
      fseek( cfPtr, ( employee.idNum - 1 ) *              
            sizeof( struct employeeData ), SEEK_SET );         
           
      fwrite( &employee, sizeof( struct employeeData ), 1, cfPtr );

      printf( "%s", "Enter account number\n? " );
      scanf( "%d", &employee.idNum );
      } 
      fclose( cfPtr ); 
      }
    } 

14. Illustrate the deadlock avoidance concept by simulating Banker’s 
algorithm with C. 
#include<stdio.h>
int main()
{
int count = 0, m, n, process, temp, resource; int allocation_table[5] = {0, 0, 0, 0, 0}; int available[5], current[5][5], maximum_claim[5][5]; int maximum_resources[5], running[5], safe_state = 0; printf("\nEnter The Total Number Of Processes:\t"); scanf("%d", &process); for(m=0;m<process;m++)
{ running[m]=1; count++;
}
printf("\nEnter The Total Number Of Resources To Allocate:\t"); scanf("%d",&resource);
printf("\nEnter The Claim Vector:\t"); for(m=0;m<resource;m++)
{
scanf("%d",&maximum_resources[m]);
}
printf("\nEnter Allocated Resource Table:\n"); for(m=0;m<process;m++)
{
for(n=0;n<resource;n++)
{
scanf("%d",&current[m][n]);
}
}
printf("\nEnter The Maximum Claim Table:\n");for(m=0;m<process;m++)
{
for(n=0;n<resource;n++)
{
scanf("%d",&maximum_claim[m][n]);
} }
printf("\nThe Claim Vector \n");
for(m=0;m<resource;m++)
{printf("\t%d ",maximum_resources[m]);
}
printf("\n The Allocated Resource Table\n"); for(m=0;m<process;m++)
{for(n=0;n<resource;n++)
{printf("\t%d",current[m][n]);
} printf("\n");
}printf("\nThe Maximum Claim Table \n"); for(m=0;m<process;m++)
{for(n=0;n<resource;n++)
{printf("\t%d",maximum_claim[m][n]);
} printf("\n");
}for(m=0;m<process;m++)
{for(n=0;n<resource;n++)
{allocation_table[n]=allocation_table[n]+current[m][n];
}}
printf("\nAllocated Resources \n"); for(m=0;m<resource;m++)
{printf("\t%d",allocation_table[m]);
}for(m=0;m<resource;m++)
{
available[m]=maximum_resources[m]-allocation_table[m];
}
printf("\nAvailable Resources:");
for(m=0;m<resource;m++)
{
printf("\t%d",available[m]);
} printf("\n"); while(count!=0)
{ safe_state=0;
for(m=0;m<process;m++)
{
if(running[m])
{ temp=1;
for(n=0;n<resource;n++)
{
if(maximum_claim[m][n]-current[m][n]>available[n])
{ temp=0; break;
}
} if(temp)
{
printf("\nProcess %d Is In Execution \n", m + 1); running[m]=0; count--; safe_state=1;
for(n=0;n<resource;n++)
{available[n]=available[n]+current[m][n];
} break;
}}}if(!safe_state)
{printf("\nThe Processes Are In An Unsafe State \n"); break; } else
{printf("\nThe Process Is In A Safe State \n"); printf("\nAvailable Vector\n");
for(m=0;m<resource;m++)
{printf("\t%d",available[m]);
} printf("\n");
}}
}
15 Construct a C program to simulate producer-consumer problem using 
semaphores. 
#include<stdio.h> 
#include <stdlib.h> 
int mutex = 1; 
int full = 0; 
int empty = 10, x = 0; 
void producer() 
{ 
--mutex; 
++full; 
--empty; 
x++; 
printf("\nProducer produces item %d",x); 
++mutex; 
} 
void consumer() 
{ 
--mutex; 
--full; 
++empty; 
printf("\nConsumer consumes " 
"item %d", 
x); 
x--; 
++mutex; 
} 
int main() 
{ 
int n, i; 
printf("\n1. Press 1 for Producer" 
"\n2. Press 2 for Consumer" 
"\n3. Press 3 for Exit"); 
for (i = 1; i > 0; i++) { 
printf("\nEnter your choice:"); 
scanf("%d", &n); 
switch (n) { 
case 1: 
if ((mutex == 1) 
&& (empty != 0)) { 
producer(); 
} 
else { 
} 
break; 
case 2: 
printf("Buffer is full!"); 
if ((mutex == 1) 
&& (full != 0)) { 
consumer(); 
} 
else { 
} 
break; 
case 3:
printf("Buffer is empty!"); 
exit(0); 
break; 
} 
} 
}
 
16. Construct a C program to simulate the First in First Out paging
 technique of memory management.
#include<stdio.h>
int main()
{
    int incomingStream[] = {4, 1, 2, 4, 5};
    int pageFaults = 0;
    int frames = 3;
    int m, n, s, pages;

    pages = sizeof(incomingStream)/sizeof(incomingStream[0]);

    printf("Incoming \t\tFrame 1 \t\tFrame 2 \t\tFrame 3");
    int temp[frames];
    for(m = 0; m < frames; m++)
    {
        temp[m] = -1;
    }

    for(m = 0; m < pages; m++)
    {
        s = 0;

        for(n = 0; n < frames; n++)
        {
            if(incomingStream[m] == temp[n])
            {
                s++;
                pageFaults--;
            }
        }
        pageFaults++;
        
        if((pageFaults <= frames) && (s == 0))
        {
            temp[m] = incomingStream[m];
        }
        else if(s == 0)
        {
            temp[(pageFaults - 1) % frames] = incomingStream[m];
        }
      
        printf("\n");
        printf("%d\t\t\t",incomingStream[m]);
        for(n = 0; n < frames; n++)
        {
            if(temp[n] != -1)
                printf(" %d\t\t\t", temp[n]);
            else
                printf(" - \t\t\t");
        }
    }

    printf("\nTotal Page Faults:\t%d\n", pageFaults);
    return 0;
}

17. Construct a C program to simulate the Least Recently Used paging
 technique of memory management.
#include<stdio.h>
main()
{
int q[20],p[50],c=0,c1,d,f,i,j,k=0,n,r,t,b[20],c2[20];
printf("Enter no of pages:");
scanf("%d",&n);
printf("Enter the reference string:");
for(i=0;i<n;i++)
            scanf("%d",&p[i]);
printf("Enter no of frames:");
scanf("%d",&f);
q[k]=p[k];
printf("\n\t%d\n",q[k]);
c++;
k++;
for(i=1;i<n;i++)
{
    c1=0;
    for(j=0;j<f;j++)
	{
        if(p[i]!=q[j])
        c1++;
    }
    if(c1==f)
    {
    c++;
        if(k<f)
        {
        q[k]=p[i];
        k++;
        for(j=0;j<k;j++)
        printf("\t%d",q[j]);
        printf("\n");
        }
        else
        {
        for(r=0;r<f;r++)
        {
        c2[r]=0;
    	for(j=i-1;j<n;j--)
        {
        if(q[r]!=p[j])
        c2[r]++;
        else
        break;
    	}
    }
    for(r=0;r<f;r++)
    b[r]=c2[r];
    for(r=0;r<f;r++)
    {
    for(j=r;j<f;j++)
    {
    if(b[r]<b[j])
    {
    t=b[r];
    b[r]=b[j];
    b[j]=t;
	}
	}
    }
    for(r=0;r<f;r++)
    {
    if(c2[r]==b[0])
    q[r]=p[i];
    printf("\t%d",q[r]);
    }
    printf("\n");
    }
	}
}
printf("\nThe no of page faults is %d",c);
}

18. Construct a C program to simulate the optimal paging technique of
 memory management  
#include<stdio.h>
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);
    
    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);
    
    printf("Enter page reference string: ");
    
    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }
    
    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
        flag1 = flag2 = 0;
        
        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                   flag1 = flag2 = 1;
                   break;
               }
        }
        
        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    faults++;
                    frames[j] = pages[i];
                    flag2 = 1;
                    break;
                }
            }    
        }
        
        if(flag2 == 0){
         flag3 =0;
        
            for(j = 0; j < no_of_frames; ++j){
             temp[j] = -1;
            
             for(k = i + 1; k < no_of_pages; ++k){
             if(frames[j] == pages[k]){
             temp[j] = k;
             break;
             }
             }
            }
            
            for(j = 0; j < no_of_frames; ++j){
             if(temp[j] == -1){
             pos = j;
             flag3 = 1;
             break;
             }
            }
            
            if(flag3 ==0){
             max = temp[0];
             pos = 0;
            
             for(j = 1; j < no_of_frames; ++j){
             if(temp[j] > max){
             max = temp[j];
             pos = j;
             }
             }            
            }
frames[pos] = pages[i];
faults++;
        }
        
        printf("\n");
        
        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }
    
    printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}

19. Consider a file system where the records of the file are stored one 
after another both physically and logically. A record of the file can 
only be accessed by reading all the previous records.  Design a C program
 to simulate the file allocation strategy.
#include <stdio.h> 
#include <conio.h> 
#include <stdlib.h> 
void recurse(int files[]){ 
 int flag = 0, startBlock, len, j, k, ch; 
 printf("Enter the starting block and the length of the files: "); 
 scanf("%d%d", &startBlock, &len); 
 for (j=startBlock; j<(startBlock+len); j++){ 
 if (files[j] == 0) 
 flag++; 
 } 
 if(len == flag){ 
 for (k=startBlock; k<(startBlock+len); k++){ 
 if (files[k] == 0){ 
 files[k] = 1; 
 printf("%d\t%d\n", k, files[k]); 
 } 
 } 
 if (k != (startBlock+len-1)) 
 printf("The file is allocated to the disk\n"); 
 } 
 else 
 printf("The file is not allocated to the disk\n"); 
 printf("Do you want to enter more files?\n"); 
 printf("Press 1 for YES, 0 for NO: "); 
 scanf("%d", &ch); 
 if (ch == 1) 
 recurse(files); 
 else 
 exit(0); 
 return; 
} 
int main() 
{ 
int files[50],i; 
{
for(i=0;i<50;i++) 
files[i]=0; 
printf("Files Allocated are :\n"); 
recurse(files); 
getch(); 
return 0; 
}
}

20. Consider a file system that brings all the file pointers together 
into an index block. The ith entry in the index block points to the ith
 block of the file. Design a C program to simulate the file allocation 
strategy.
#include<stdio.h> 
#include<conio.h> 
#include<stdlib.h> 
int main() 
{ 
int f[50], index[50],i, n, st, len, j, c, k, ind,count=0; 
for(i=0;i<50;i++) 
f[i]=0; 
x:printf("Enter the index block: "); 
scanf("%d",&ind); 
if(f[ind]!=1) 
{ 
printf("Enter no of blocks needed and no of files for the index %d on the disk : \n", ind); 
scanf("%d",&n); 
} 
else 
{ 
printf("%d index is already allocated \n",ind); 
goto x; 
} 
y: count=0; 
for(i=0;i<n;i++) 
{ 
scanf("%d", &index[i]); 
if(f[index[i]]==0) 
count++; 
} 
if(count==n) 
{ 
for(j=0;j<n;j++) 
f[index[j]]=1; 
printf("Allocated\n"); 
printf("File Indexed\n"); 
for(k=0;k<n;k++) 
printf("%d-------->%d : %d\n",ind,index[k],f[index[k]]); 
} 
else
{ 
printf("File in the index is already allocated \n"); 
printf("Enter another file indexed"); 
goto y; 
} 
printf("Do you want to enter more file(Yes - 1/No - 0)"); 
scanf("%d", &c); 
if(c==1) 
goto x; 
else 
exit(0); 
getch(); 
}

21. With linked allocation, each file is a linked list of disk blocks; 
the disk blocks may be scattered anywhere on the disk. The directory
 contains a pointer to the first and last blocks of the file.  Each block
 contains a pointer to the next block. Design a C program to simulate the
 file allocation strategy.
#include<stdio.h> 
#include<conio.h> 
#include<stdlib.h> 
int main() 
{ 
int f[50], p,i, st, len, j, c, k, a; 
for(i=0;i<50;i++) 
f[i]=0; 
printf("Enter how many blocks already allocated: "); 
scanf("%d",&p); 
printf("Enter blocks already allocated: "); 
for(i=0;i<p;i++) 
{ 
scanf("%d",&a); 
f[a]=1; 
} 
x: printf("Enter index starting block and length: "); 
scanf("%d%d", &st,&len); 
k=len; 
if(f[st]==0) 
{ 
for(j=st;j<(st+k);j++) 
{ 
if(f[j]==0) 
{ 
f[j]=1; 
printf("%d-------->%d\n",j,f[j]); 
} 
else 
{ 
printf("%d Block is already allocated \n",j); 
k++; 
} 
} 
} 
else 
printf("%d starting block is already allocated \n",st); 
printf("Do you want to enter more file(Yes - 1/No - 0)"); 
scanf("%d", &c); 
if(c==1) 
goto x; 
else 
exit(0); 
getch(); 
}

22. Construct a C program to simulate the First Come First Served disk
 scheduling algorithm. 
#include<math.h> 
#include<stdio.h> 
#include<stdlib.h> 
int main() 
{ 
 int i,n,req[50],mov=0,cp; 
 printf("enter the current position\n"); 
 scanf("%d",&cp); 
 printf("enter the number of requests\n"); 
 scanf("%d",&n); 
 printf("enter the request order\n"); 
 for(i=0;i<n;i++) 
 { 
 scanf("%d",&req[i]); 
 } 
 mov=mov+abs(cp-req[0]); 
 printf("%d -> %d",cp,req[0]); 
 for(i=1;i<n;i++) 
 { 
 mov=mov+abs(req[i]-req[i-1]); 
 printf(" -> %d",req[i]); 
 } 
 printf("\n"); 
 printf("total head movement = %d\n",mov); 
}

 
23. Design a C program to simulate SCAN disk scheduling algorithm.
24.. Develop a C program to simulate C-SCAN disk scheduling algorithm.
25. Illustrate the various File Access Permission and different types
 users in Linux.